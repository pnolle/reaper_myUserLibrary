/*******************************************************************************
*  Altered to transpose in full octaves by @pnolle 2024                        *
*  Why? I'd like to control the MIDI octave with a MIDI controller knob.       *
*  I only need full octaves to skip through song setups in ``ReaDrum``.        *
*                                                                              *
*  Copyright 2007 - 2011, Philip S. Considine                                  *
*  This program is free software: you can redistribute it and/or modify        *
*  it under the terms of the GNU General Public License as published by        *
*  the Free Software Foundation, either version 3 of the License, or           *
*  (at your option) any later version.                                         *
*                                                                              *
*  This program is distributed in the hope that it will be useful,             *
*  but WITHOUT ANY WARRANTY; without even the implied warranty of              *
*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the                *
*  GNU General Public License (http://www.gnu.org/licenses/)for more details.  *
*******************************************************************************/

desc: MIDI Router/Transpose full octave
desc: MIDI Router/Transpose full octave [IXix]
//tags: MIDI processing routing
//author: IXix / altered by @pnolle

slider1:0<0,15,1{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16}>Input Channel
slider2:0<0,15,1{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16}>Output Channel
slider3:3<0,3,1{Off, Notes, Non-Notes, Both}>Mode
slider4:0<0,127,1>Note Min
slider5:127<0,127,1>Note Max
slider6:4<0,10,1>Transpose octave (12 notes)
slider7:/octave_configs:none:Octaves config

in_pin:none
out_pin:none

////////////////////////////////////////////////////////////////////////////////
@init
statNoteOn = $x90;
statNoteOff = $x80;

// display variables
octave_names = 0[]; // Initialize array for song names
mapSize = 0;

////////////////////////////////////////////////////////////////////////////////
@slider

slider4 = min(max(slider4 | 0, 0), 127);  // Remove fractions and clamp to legal range
slider5 = min(max(slider5 | 0, 0), 127);
slider6 = min(max(slider6 | 0, 0), 10);

inChannel = slider1;
outChannel = slider2;
mode = slider3;
noteMin = slider4;
noteMax = slider5;
transpose = (slider6 - 4) * 12; // the octave value

// Function to find the position of '=' in a string
function find_eq_pos(line) (
  eqPos = -1;
  i = 0;
  while (i < strlen(line)) (
    str_getchar(line, i) == 61 ? (eqPos = i; break;); // 61 is ASCII for '='
    i += 1;
  );
  eqPos;
);

// Manual splitting without strmid or strchr
function split_line(line) (
  eqPos = -1;
  i = 0;
  while (i < strlen(line)) (
    str_getchar(line, i) == 61 ? (eqPos = i; break;); // ASCII 61 = '='
    i += 1;
  );
  eqPos > 0 ? (
    octave = 0;
    j = 0;
    while (j < eqPos) ( // Extract part before '='
      octave = octave * 10 + (str_getchar(line, j) - 48); // Convert char to int
      j += 1;
    );
    songName = "";
    j = eqPos + 1;
    while (j < strlen(line)) ( // Extract part after '='
      songName += str_getchar(line, j);
      j += 1;
    );
    octave >= 0 && octave <= 10 ? (octave_names[octave] = songName; mapSize += 1;);
  );
);

// Read octave-to-song mappings from a config file
mapFile = slider2;
fileHandle = file_open(slider7);
printf("Opening file: %s\n", slider7);
fileHandle > 0 ?
(
  file_text(fileHandle) ? while  // Read each line of the file
  (
    file_var(fileHandle, line); // Read the current line into 'line'
    split_line(line);
  );
  file_close(fileHandle);
) : mapFile = -1;

////////////////////////////////////////////////////////////////////////////////
@block
while
(
  midirecv(offset, msg1, msg23) ?
  (  
    // Extract message type and channel
    status = msg1 & $xF0;
    channel = msg1 & $x0F;
      
    // Is it on our channel?
    channel == inChannel ? 
    (
      // Note events are always redirected
      (status == statNoteOn || status == statNoteOff) ?
      (
        // Extract note value
        note = msg23 & $x7F;
          
        // Is it within our note range?
        mode & 1 ?
        (
          note >= noteMin && note <= noteMax ?
          (  
            // Transpose and clamp
            note += transpose;
            note < 0 ? note = 0; note > 127 ? note = 127;

            // Modify MIDI message data
            msg1 = status + outChannel;
            msg23 = (msg23 & $xFF00) | note;
          );
        );
      )
      : mode & 2 ? // Redired non-note events if necessary
      (
        msg1 = status + outChannel;
      );
    );
    
    // Pass message on
    midisend(offset, msg1, msg23);
    
    1; // Force loop to continue until all messages have been processed
  );
);


printf("OPcate: %s\n", slider6);

// Graphical display
@gfx 360 360
gfx_clear = 0x000000;       // Set the full background color to black

gfx_setfont(1, "Arial", 40); // Set the font
gfx_set(1, 1, 1, 1);         // White color for text

gfx_x = 10; gfx_y = 10;

// slider6 containing the current octave number
gfx_printf("%d - %s", slider6, octave_names[slider6] != "" ? octave_names[slider6] : "No mapping"); 
